---
title: "Group Project 4 COVID"
author: 'covid_p11'
date: '2022-03-28'
output:
  html_document:
    toc: true
    number_sections: false
    theme: flatly
    highlight: tango
    toc_float: true
    toc_depth: 4
    code_folding: hide
---

```{r setup, include=FALSE}
library(tidyverse)
library(ggplot2)
library(maps)
library(plotly)
library(caret)
library(dplyr)
library(lubridate)
library("scales")
library("magrittr")
library("tidyr")
```

Topic: COVID-19 New cases
visualisation dashboard: Shiny app
```{r}
covid = read.csv("owid-covid-data.csv")

# these are indices for each country (an index is just a collection of stocks)
# 'FileEncoding' just cleans the column encoding for this case

#sp500 = read.csv("SPY Historical Data.csv", fileEncoding = 'UTF-8-BOM') # This is for US
#TOPIX = read.csv("TOPIX Historical Data.csv", fileEncoding = 'UTF-8-BOM') # This is for Japan
ASX200 = read.csv("S&P_ASX 200 Historical Data.csv", fileEncoding = 'UTF-8-BOM') # This is for Australia
#NSEI = read.csv("Nifty 50 Historical Data.csv", fileEncoding = 'UTF-8-BOM') # This is for India
#SSEC = read.csv("Shanghai Composite Historical Data.csv", fileEncoding = 'UTF-8-BOM') # this is for China

colnames(covid)
```

# data clean
```{r}
#Dropping NA
covid_clean = covid %>% drop_na(new_cases, new_cases_smoothed, new_vaccinations, new_vaccinations_smoothed, new_vaccinations_smoothed_per_million, population, population_density, median_age, extreme_poverty, total_vaccinations, hospital_beds_per_thousand, human_development_index, new_deaths, new_tests, weekly_icu_admissions_per_million, weekly_icu_admissions)

#This code changes the negative case values in the data set to zero
covid_clean$new_cases[covid_clean$new_cases < 0] <- 0

covid_AUS <- covid %>% filter(location == "Australia")
covid_clean_AUS = covid_AUS %>% drop_na(new_cases, new_cases_smoothed, new_vaccinations, new_vaccinations_smoothed, new_vaccinations_smoothed_per_million, population, population_density, median_age, extreme_poverty, total_vaccinations, hospital_beds_per_thousand, human_development_index, new_deaths, new_tests)

#This code changes the negative case values in the data set to zero
covid_clean_AUS$new_cases[covid_clean_AUS$new_cases < 0] <- 0
view(covid_clean_AUS)

#glimpse(covid_clean)
#covid_clean$date = as.Date(covid_clean$date)
#max(covid_clean$date)
#unique(covid_clean$location)
```

# Question 1

```{r}
#code for more optimised join (to be pasted later)
class(covid_clean$date)
```


# performing join

```{r}
# using a copy just in case
covid2 <- covid_clean_AUS

#sp500$date = mdy(sp500$Date)
#TOPIX$date = mdy(TOPIX$Date)
ASX200$date = mdy(ASX200$Date)
#NSEI$date = mdy(NSEI$Date)
#SSEC$date = mdy(SSEC$Date)
covid2$date = ymd(covid2$date)

#Temporarily changing the date to character as joining cannot be done with date objects
#Also selecting relevant columns for analysis later
covid2 <- covid2 %>%
  transform(covid2, date = as.character(date)) %>% 
  select(date, new_cases, new_deaths, location, new_vaccinations, new_tests, population, population_density)
#sp500$date <- as.character(sp500$Date)
#TOPIX$date <- as.character(TOPIX$Date)
ASX200$date <- as.character(ASX200$date)
#NSEI$date <- as.character(NSEI$Date)
#SSEC$date <- as.character(SSEC$Date)

# renaming column so it has same name as the stock market data frames for joining later
#colnames(covid2)[1] = "Date"

# making data frames for each country we select to perform individual joins on each to their respective stock market index
#covid_US <- covid2 %>% filter(location == "United States")
covid_AUS <- covid2 %>% filter(location == "Australia")
#covid_IND <- covid2 %>% filter(location == "India")
#covid_JPN <- covid2 %>% filter(location == "Japan")
#covid_CHN <- covid2 %>% filter(location == "China")

# performing joins 
#df_1 = inner_join(sp500, covid_US, by = "date")
#df_2 = inner_join(TOPIX, covid_JPN, by = "date")
df_3 = inner_join(ASX200, covid_AUS, by = "date")
#df_4 = inner_join(NSEI, covid_IND, by = "date")
#df_5 = inner_join(SSEC, covid_CHN, by = "date")

# vertically joined data set (now one column will store all the values of the respective country index)
# e.g US stores prices relevant to S&P500 and China's prices are relevant to the the SSEC which is based in Shanghai.
#covid_joined <- rbind(df_1, df_2, df_3, df_4, df_5)

# Still need transform relevant column to numeric ect...will do a little later 

df_aus <- df_3

#transformation
df_aus$date = as.Date(df_aus$date)
df_aus$Price = as.numeric(gsub(",","",df_aus$Price))

df_aus
```

## For new_cases_smoothed

# Impact on finicial market

# relationship between new cases and vaccination

# Initial analysis for new_cases_smoothed

```{r}
covid_temp <- covid_clean
covid_temp$month <- strftime(covid_temp$date, "%m")
covid_temp$year  <- strftime(covid_temp$date, "%Y")

covid_temp_new_case_aggregate <- aggregate(new_cases_smoothed~month+year, 
                  covid_temp,
                  FUN = mean)
covid_temp_new_case_aggregate$month_year <- paste(covid_temp_new_case_aggregate$month, covid_temp_new_case_aggregate$year)
```


```{r}
ggplot(covid_temp_new_case_aggregate, aes(x= new_cases_smoothed, y= month_year)) +
  geom_bar(stat = 'identity') + ggtitle("Average New Cases (Smoothed) per Month") +
  ylab("month year") + xlab("average new cases")
```

- Analysis: From the above bar plot, we set different months of 2021 and 2022 as y-axis and the average smoothed new cases for each month as x-axis. We can easily know that smoothed new cases in most months are less than 30,000 except in Jan, 2022, which is nearly 50,000. So the data of new_cases_smoothed is evenly distributed and has a small standard deviation.

# Initial analysis for new_people_vaccinated_smoothed
```{r}
covid_temp = covid_clean %>% select(date,new_people_vaccinated_smoothed)
covid_temp$date <- as.Date(covid_temp$date, format = "%Y-%m-%d")
covid_temp_new_vaccinated_aggregate = covid_temp %>% mutate(month_year = as.character(format(date, "%m-%Y"))) %>%
          group_by(month_year) %>%
  summarise(date=date[1], number = mean(new_people_vaccinated_smoothed))
covid_temp_new_vaccinated_aggregate  
```

```{r, warning=FALSE}
ggplot(covid_temp_new_vaccinated_aggregate, aes(x = number, y= month_year)) +
  geom_bar(stat = 'identity') + ggtitle("Average New People Vaccinated (Smoothed) per Month") +
  ylab("month year") + xlab("average new people vaccinated")
```

- Analysis: Most number show above are larger than 100000. Many people get vaccinated in July, August and September in 2021, and less people get vaccinated before and after that period which is reasonable since it takes time to invent and promote new vaccines.

# Q2 a
## Price ~ new_cases
```{r, warning=FALSE}
#glimpse(df_aus)
df_aus_subset = df_aus %>% select(Price, new_cases)
df_aus_subset

M0 = lm(Price ~ new_cases, data = df_aus_subset) # Null model
summary(M0)
```

- Analysis(Paul and Christin): We build a linear model here to explore relationship between stock prices and new cases of covid-19. The dependent variable here is stock prices while independent variable is new cases. Although the r-squared value is quite low and Residual standard error is a bit high, which indicates our model is not good, the p-value for new cases is 0.044( < 0.05), so it is a significantly influence Price. The final model we get is $\text{Price} = 1.166e^{-03}\times \text{new_cases} + 7.223e^{03}$.

Scatter Plot for price and new_cases


```{r}
df_aus = df_aus[order(as.Date(df_aus$date, format="%d/%m/%Y")),]
df_aus
df_aus$logPrice = log(df_aus$Price)
colnames(df_aus)[7] = 'Change'
write.csv(df_aus,"df_aus.csv")
```

```{r}
y <- df_aus$Price
x <- df_aus$new_cases

plot(x, y, main = "Price ~ New Cases",
     ylab = "Price", xlab = "new_cases",
     pch = 19, frame = FALSE)
# Add regression line
plot(x, y, main = "Price ~ New Cases",
     ylab = "Price", xlab = "new_cases",
     pch = 19, frame = FALSE)
abline(lm(y ~ x, data = df_aus), col = "blue")
```

## Price ~ new_vaccinations
```{r}
df_aus_subset = df_aus %>% select(Price, new_vaccinations)
df_aus_subset

M1 = lm(Price ~ poly(new_vaccinations, degree=2), data=df_aus_subset)
summary(M1)
```

```{r}
ggplot(data = df_aus, mapping = aes(x = new_vaccinations, y = Price)) + geom_point() + ggtitle("Prices of stocks against new vaccinations") + xlab("New vaccinations") + ylab("Price")
```

## Price ~ New tests
```{r}
df_aus_subset = df_aus %>% select(Price, new_tests)
df_aus_subset
M2 = lm(Price ~ poly(new_tests, degree=2), data=df_aus_subset)
summary(M2)
```

```{r}
ggplot(data = df_aus, mapping = aes(x = new_tests, y = Price)) + geom_point() + ggtitle("Prices of stocks against new tests") + xlab("New tests") + ylab("Price")
```

```{r}
ggplot(data = df_aus, mapping = aes(x = Price, y = population)) + geom_point() + ggtitle("Prices of stocks against population") + ylab("New tests") + xlab("Price")
ggplot(data = df_aus, mapping = aes(x = Price, y = population_density)) + geom_point() + ggtitle("Prices of stocks against population density") + ylab("New tests") + xlab("Price")
ggplot(data = df_aus, mapping = aes(x = date, y = population_density)) + geom_line() + ggtitle("Prices of stocks against population density") + ylab("New tests") + xlab("Price") # bad
summary(df_aus$Price)
```

```{r}
df_aus$Price_mul30 = df_aus$Price*30
p1 = ggplot(data = df_aus) + geom_line(aes(x=date, y = new_cases), color = "red") + geom_line(aes(x=date, y = new_vaccinations), color = "light green") + geom_line(aes(x=date, y = new_tests), color = "light blue")+ theme_bw()
ggplotly(p1)
```

```{r}
M = lm(logPrice ~ polym(new_tests, new_vaccinations, degree=2, raw=TRUE), data=df_aus)
summary(M)
#autoplot(M, which = 1:2)
ggplot(data = df_aus) + geom_point(aes(x = new_tests, y = logPrice), color = "light blue") +
  geom_point(aes(x = new_vaccinations, y = logPrice), color = "light green") +
  ggtitle("Prices of stocks against new tests and new_vaccinations") + ylab("Price") +theme_classic()
```

- The behaviour of a dependent variable is explained by a linear, or curvilinear, additive relationship between the dependent variable and a set of k independent variables (xi, i=1 to k).
- The relationship between the dependent variable and any independent variable is linear or curvilinear.
- The independent variables do no depend on each other too.
- The errors are independent, normally distributed with mean zero and a constant variance.

```{r}
# test commit code from r studio cloud by maxim 
```
